  /*
  This file is part of "GMP Clearview" package.
  Copyright (C)  2025 Infotrust 
  Alina Zilbergerts, Trish Dothkar,
  -- */

config {
  type: "incremental",
  tags: [dataform.projectConfig.vars.GA4_DATASET,"base_items","prod"],
  description: "Output events table: unnested, cleaned, clustered data with several fixes",
  database: dataform.projectConfig.vars.OUTPUT_PROJECT,
  schema: dataform.projectConfig.vars.TRANSFORMATIONS_DATASET,
  name: "base_ga4_items",
  bigquery: {
    partitionBy: "event_date",
    clusterBy: ["event_name", "session_id"]
  }
}

  -- ==============================
  --        JS BLOCK
  -- ==============================


js {

  const helpers  = require("includes/helper_functions");` `
  const config = helper_functions.getConfig();

  /* check if there's invalid columns or dupe columns in the custom column definitions */
  helpers.checkColumnNames(config);

  var dateFilter = "" ;
  if (dataform.projectConfig.vars.RUN_FOR_DATE != undefined) {
    dateFilter = `parse_date('%Y%m%d', regexp_extract(_table_suffix,'[0-9]+')) = date_checkpoint `;
  } else { 
         dateFilter = ` _table_suffix >= '20250701' `;
    // dateFilter = `parse_date('%Y%m%d', regexp_extract(_table_suffix,'[0-9]+')) >= date_checkpoint `;

  }

}

  -- ==============================
  --        PRE-OPERATIONS
  -- ==============================
pre_operations {
  declare date_checkpoint DATE;
    ---  // this triple dash means something in dataform?

  -- this is for when we need to refill for certain date
  IF '${dataform.projectConfig.vars.RUN_FOR_DATE}' <> 'undefined' THEN 
    set date_checkpoint = (
      ${when(incremental(), 
          `select date('${dataform.projectConfig.vars.RUN_FOR_DATE}')`, 
          `select date('${config.GA4_START_DATE}')`
           )
      });
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where event_date = date_checkpoint;`
          )
      }
  ELSE
      set date_checkpoint = (
        ${when(incremental(),
        `select coalesce(max(event_date)+1, date('${config.GA4_START_DATE}'))
            from ${self()} 
            where is_final is True`,
        `select date('${config.GA4_START_DATE}')`)} 
      );
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where event_date >= date_checkpoint;`
          )
      }
    END IF;

}

  -- ==============================
  --        POST-OPERATIONS
  -- ==============================
post_operations {
    -- Export file into Cloud storage if requested in Config
    ${when(incremental() && dataform.projectConfig.vars.EXPORT_TO_GCS == 'True',
      `${helpers.generateExportDataSQL(dataform.projectConfig.vars.TRANSFORMATIONS_DATASET, self(), name())
      }`
   )}
}

  -- ==============================
  --        QUERY
  -- ==============================


with query_source as (

    select
      _table_suffix as table_suffix,
      *
    from ${ref("events_*")}

    where true

    -- incrementality clause
    --  and parse_date('%Y%m%d', regexp_extract(_table_suffix,'[0-9]+')) >= date_checkpoint 
    --  and parse_date('%Y%m%d', regexp_extract(_table_suffix,'[0-9]+')) <= '2025-09-02' 
    and ${dateFilter}

    -- filters go here

    -- intraday filter: exclude
    and contains_substr(_table_suffix, 'intraday') is false
    -- fresh filter: exclude
    and contains_substr(_table_suffix, 'fresh') is false

    -- filters from config:
    -- discard unwanted events
    and ${helpers.generateFilterTypeFromListSQL("exclude", "event_name", config.EVENTS_TO_EXCLUDE)}
    -- discard unwanted hostnames
    and ${helpers.generateFilterTypeFromListSQL("exclude", "device.web_info.hostname", config.HOSTNAME_EXCLUDE)}
    -- only include wanted hostnames
    and ${helpers.generateFilterTypeFromListSQL("include", "device.web_info.hostname", config.HOSTNAME_INCLUDE_ONLY)}

    -- leave cookieless pings in - those will be in the events table and  do not have a session
    -- and user_pseudo_id is not null

),

step1 as (

  select
    -- first chunk: the basics
    table_suffix,
    event_timestamp,

    event_name,
    parse_date('%Y%m%d', event_date) as event_date, -- partition column
    date(datetime(timestamp_micros(event_timestamp), '${dataform.projectConfig.vars.LOCAL_TIMEZONE}')) as event_date_local,
    date_diff(current_date(), cast(event_date as date format 'YYYYMMDD'), day) > ${config.DATA_IS_FINAL_DAYS} as is_final, -- used for incrementality
    stream_id,
    platform,
    struct(
      -- timestamps
      event_timestamp,
      timestamp_micros(event_timestamp) as event_timestamp_utc,
      user_first_touch_timestamp as user_first_touch_timestamp,
      timestamp_micros(user_first_touch_timestamp) as user_first_touch_timestamp_utc    
    ) as time,
    
    -- user info
    user_pseudo_id,
    user_id,
    is_active_user,

    -- event info
    batch_event_index,
    batch_ordering_id,
    batch_page_id,

    -- now the structs - we will need to explicitly name ALL fields herein, as to not break incremental builds when Google adds a column in a struct
    -- privacy info
    struct(
      privacy_info.analytics_storage as analytics_storage,
      privacy_info.ads_storage as ads_storage,
      privacy_info.uses_transient_token as uses_transient_token
    ) as privacy_info,
    
    struct(
      collected_traffic_source.manual_campaign_id,
      collected_traffic_source.manual_campaign_name,
      collected_traffic_source.manual_source,
      collected_traffic_source.manual_medium,
      collected_traffic_source.manual_term,
      collected_traffic_source.manual_content,
      collected_traffic_source.manual_source_platform,
      collected_traffic_source.manual_creative_format,
      collected_traffic_source.manual_marketing_tactic,
      collected_traffic_source.gclid,
      collected_traffic_source.dclid,
      collected_traffic_source.srsltid
    ) as collected_traffic_source, -- as is. This will be fixed in the next step

    struct(
      struct(
        session_traffic_source_last_click.manual_campaign.campaign_id,
        session_traffic_source_last_click.manual_campaign.campaign_name,
        session_traffic_source_last_click.manual_campaign.source,
        session_traffic_source_last_click.manual_campaign.medium,
        session_traffic_source_last_click.manual_campaign.term,
        session_traffic_source_last_click.manual_campaign.content,
        session_traffic_source_last_click.manual_campaign.source_platform,
        session_traffic_source_last_click.manual_campaign.creative_format,
        session_traffic_source_last_click.manual_campaign.marketing_tactic
      ) as manual_campaign,
      struct(
        session_traffic_source_last_click.google_ads_campaign.customer_id,
        session_traffic_source_last_click.google_ads_campaign.account_name,
        session_traffic_source_last_click.google_ads_campaign.campaign_id,
        session_traffic_source_last_click.google_ads_campaign.campaign_name,
        session_traffic_source_last_click.google_ads_campaign.ad_group_id,
        session_traffic_source_last_click.google_ads_campaign.ad_group_name       
      ) as google_ads_campaign,
      struct(
        session_traffic_source_last_click.cross_channel_campaign.campaign_name,
        session_traffic_source_last_click.cross_channel_campaign.campaign_id,
        session_traffic_source_last_click.cross_channel_campaign.source,
        session_traffic_source_last_click.cross_channel_campaign.medium,
        session_traffic_source_last_click.cross_channel_campaign.source_platform,
        session_traffic_source_last_click.cross_channel_campaign.default_channel_group,
        session_traffic_source_last_click.cross_channel_campaign.primary_channel_group
      ) as cross_channel_campaign,
      struct(
        session_traffic_source_last_click.sa360_campaign.campaign_id,
        session_traffic_source_last_click.sa360_campaign.campaign_name,
        session_traffic_source_last_click.sa360_campaign.source,
        session_traffic_source_last_click.sa360_campaign.medium,
        session_traffic_source_last_click.sa360_campaign.ad_group_id,
        session_traffic_source_last_click.sa360_campaign.ad_group_name,
        session_traffic_source_last_click.sa360_campaign.creative_format,
        session_traffic_source_last_click.sa360_campaign.engine_account_name,
        session_traffic_source_last_click.sa360_campaign.engine_account_type,
        session_traffic_source_last_click.sa360_campaign.manager_account_name
      ) as sa360_campaign,
      struct(
        session_traffic_source_last_click.cm360_campaign.campaign_id,
        session_traffic_source_last_click.cm360_campaign.campaign_name,
        session_traffic_source_last_click.cm360_campaign.source,
        session_traffic_source_last_click.cm360_campaign.medium,
        session_traffic_source_last_click.cm360_campaign.account_id,
        session_traffic_source_last_click.cm360_campaign.account_name,
        session_traffic_source_last_click.cm360_campaign.advertiser_id,
        session_traffic_source_last_click.cm360_campaign.advertiser_name,
        session_traffic_source_last_click.cm360_campaign.creative_id,
        session_traffic_source_last_click.cm360_campaign.creative_format,
        session_traffic_source_last_click.cm360_campaign.creative_name,
        session_traffic_source_last_click.cm360_campaign.creative_type,
        session_traffic_source_last_click.cm360_campaign.creative_type_id,
        session_traffic_source_last_click.cm360_campaign.creative_version,
        session_traffic_source_last_click.cm360_campaign.placement_id,
        session_traffic_source_last_click.cm360_campaign.placement_cost_structure,
        session_traffic_source_last_click.cm360_campaign.placement_name,
        session_traffic_source_last_click.cm360_campaign.rendering_id,
        session_traffic_source_last_click.cm360_campaign.site_id,
        session_traffic_source_last_click.cm360_campaign.site_name
      ) as cm360_campaign,
      struct(
        session_traffic_source_last_click.dv360_campaign.campaign_id,
        session_traffic_source_last_click.dv360_campaign.campaign_name,
        session_traffic_source_last_click.dv360_campaign.source,
        session_traffic_source_last_click.dv360_campaign.medium,
        session_traffic_source_last_click.dv360_campaign.advertiser_id,
        session_traffic_source_last_click.dv360_campaign.advertiser_name,
        session_traffic_source_last_click.dv360_campaign.creative_id,
        session_traffic_source_last_click.dv360_campaign.creative_format,
        session_traffic_source_last_click.dv360_campaign.creative_name,
        session_traffic_source_last_click.dv360_campaign.exchange_id,
        session_traffic_source_last_click.dv360_campaign.exchange_name,
        session_traffic_source_last_click.dv360_campaign.insertion_order_id,
        session_traffic_source_last_click.dv360_campaign.insertion_order_name,
        session_traffic_source_last_click.dv360_campaign.line_item_id,
        session_traffic_source_last_click.dv360_campaign.line_item_name,
        session_traffic_source_last_click.dv360_campaign.partner_id,
        session_traffic_source_last_click.dv360_campaign.partner_name
      ) as dv360_campaign
    ) 
    as session_traffic_source_last_click,

    
    ecommerce, -- for now. Will be repacked and cleaned below in step 2


    -- repack the items array struct
    -- array(
    --   (
    --     select
    --       struct(
            items.item_id,
            items.item_name,
            items.item_brand,
            items.item_variant,
            items.item_category,
            items.item_category2,
            items.item_category3,
            items.item_category4,
            items.item_category5,
            items.price_in_usd,
            items.price,
            items.quantity,
            items.item_revenue_in_usd,
            items.item_revenue,
            items.item_refund_in_usd,
            items.item_refund,
            items.coupon,
            items.affiliation,
            items.location_id,
            items.item_list_id,
            items.item_list_name,
            items.item_list_index,
            items.promotion_id,
            items.promotion_name,
            items.creative_name,
            items.creative_slot
            ${when(config.CUSTOM_ITEM_PARAMS_ARRAY.length > 0,
                `, ${helpers.generateStructSQL(
                          helpers.generateParamsSQL(config.CUSTOM_ITEM_PARAMS_ARRAY, "items.item_params"  )
                    )
                  }  as item_params_custom`)
            }
    --         )
    --     from unnest(items) as items
    --   )
    -- ) as items
      ,
    -- the programatically added SQL:
    -- grab all core event parameters - maybe we don;t need all event parameters in this table
    -- ${helpers.generateStructSQL(helpers.generateParamsSQL(config.CORE_PARAMS_ARRAY))} as event_params,

 -- add some event parameters
        STRUCT (
      (select value.int_value  from unnest(event_params) where key = 'batch_ordering_id')  as batch_ordering_id,
      (select value.int_value  from unnest(event_params) where key = 'batch_page_id')  as batch_page_id,
      (select value.int_value  from unnest(event_params) where key = 'batch_event_index')  as batch_event_index,
      (select value.int_value  from unnest(event_params) where key = 'ga_session_id')  as ga_session_id,
      (select value.int_value  from unnest(event_params) where key = 'session_engaged')  as session_engaged,
      (select value.string_value  from unnest(event_params) where key = 'page_location')  as page_location,
      (select value.string_value  from unnest(event_params) where key = 'page_referrer')  as page_referrer, 
      (select value.string_value  from unnest(event_params) where key = 'page_title')  as page_title

      ) event_params,

    -- and the custom ones
    -- ${when(
    --   config.CUSTOM_EVENT_PARAMS_ARRAY.length > 0,
    --     `${helpers.generateStructSQL(helpers.generateParamsSQL(config.CUSTOM_EVENT_PARAMS_ARRAY))} as event_params_custom,`
    --   )} 

    -- add user_properties
    ${when(
      config.CUSTOM_USER_PROPERTIES_ARRAY.length > 0,      
        `${helpers.generateStructSQL(helpers.generateParamsSQL(config.CUSTOM_USER_PROPERTIES_ARRAY,'user_properties'))} as user_properties,`
      )}


  from query_source , unnest(items) items

),

step2 as (
  -- small cleanups
  -- in July 2024, the batch_* event parameters were moved to a column. This is for backwards compatibility, let's move this too.
  select
    * except(
      ecommerce,
      batch_event_index,
      batch_ordering_id,
      batch_page_id
    ),
    
    struct(
      batch_event_index,
      coalesce(batch_ordering_id, event_params.batch_ordering_id) as batch_ordering_id,
      coalesce(batch_page_id, event_params.batch_page_id) as batch_page_id
    ) as batch,

    -- repack ecommerce struct
    -- fix transaction_id, change to NULL if "(not set)"
    -- also remove NANs in ecommerce struct
    struct(
        ecommerce.total_item_quantity,
        if(is_nan(ecommerce.purchase_revenue_in_usd), 0,ecommerce.purchase_revenue_in_usd) as purchase_revenue_in_usd,
        if(is_nan(ecommerce.purchase_revenue), 0,ecommerce.purchase_revenue) as purchase_revenue,
        if(is_nan(ecommerce.refund_value_in_usd), 0,ecommerce.refund_value_in_usd) as refund_value_in_usd,
        if(is_nan(ecommerce.refund_value), 0,ecommerce.refund_value) as refund_value,
        if(is_nan(ecommerce.shipping_value_in_usd), 0,ecommerce.shipping_value_in_usd) as shipping_value_in_usd,
        if(is_nan(ecommerce.shipping_value), 0,ecommerce.shipping_value) as shipping_value,
        if(is_nan(ecommerce.tax_value_in_usd), 0,ecommerce.tax_value_in_usd) as tax_value_in_usd,
        if(is_nan(ecommerce.tax_value), 0,ecommerce.tax_value) as tax_value,
        ecommerce.unique_items,
        if(ecommerce.transaction_id = '(not set)', null, ecommerce.transaction_id) as transaction_id
    ) as ecommerce

  from step1
),

add_meta_info as (
  select
         '${dataform.projectConfig.vars.GA4_DATASET}' as property_id,
       -- make session_id - can be NULL (if anonymous ping or MP hit without session_id)
    -- farm_fingerprint(
    --   user_pseudo_id || event_params.ga_session_id
    --  ) as session_id,
  -- coalesce(  -- AZ THIS IS A BUG - cannot coalesce user_pseudo_id and ga_session_id
  concat(
      user_pseudo_id , CAST(event_params.ga_session_id AS STRING)
     ) as session_id,
     

       -- create event ID
    farm_fingerprint(
      event_name ||
      time.event_timestamp ||
      coalesce(user_pseudo_id, 'no') ||
      coalesce(event_params.ga_session_id, 0) ||
      coalesce(batch.batch_page_id, 0) ||
      coalesce( batch.batch_ordering_id,0) ||
      coalesce( batch.batch_event_index,0) 
      -- coalesce(event_params.engagement_time_msec, 0)
    ) as event_id,
     -- create event item ID
    farm_fingerprint(
      event_name ||
      time.event_timestamp ||
      coalesce(user_pseudo_id, 'no') ||
      coalesce(event_params.ga_session_id, 0) ||
      coalesce(batch.batch_page_id, 0) ||
      coalesce( batch.batch_ordering_id,0) ||
      coalesce( batch.batch_event_index,0) ||
      coalesce(items.item_id, "") ||
      "_" || 
      REGEXP_REPLACE(items.item_variant , r'(not set)', 'no_item')
    ) as event_item_id,

 
   * except(
        time
      ),

    -- all page information in a page struct
    struct (
       lower(net.host(event_params.page_location)) as hostname,
       event_params.page_location as location,
       -- strip and leave only path - https://www.rfc-editor.org/rfc/rfc3986#appendix-B - not lowering, urls are case sensitive
       regexp_extract(event_params.page_location, r'^(?:(?:[^:\/?#]+):)?(?:\/\/(?:[^\/?#]*))?([^?#]*)(?:\?(?:[^#]*))?(?:#(?:.*))?') as path,
       event_params.page_referrer as referrer,
       event_params.page_title as title
      ) as page,
    (
        select as struct
          time.*,
          datetime(time.event_timestamp_utc, '${dataform.projectConfig.vars.LOCAL_TIMEZONE}') as timestamp_local,
          date(datetime(time.event_timestamp_utc, '${dataform.projectConfig.vars.LOCAL_TIMEZONE}')) as date_local
    ) time

  from  step2, unnest(items) items
),

-- dedupe based on event_id and remove redundant event_params
deduped as (
  select
    * replace ((select as struct event_params.* except (
                  batch_ordering_id,
                  batch_page_id,
                  page_location,
                  page_referrer,
                  page_title
                  )) as event_params),
  from add_meta_info
  qualify row_number() over ( partition by event_item_id ) = 1
)

,add_row_numbers as (
  select
    *,
    struct(
    -- calculate hit numbers per session (now is the time)
    if(user_pseudo_id is not null and event_params.ga_session_id is not null,
        row_number() over (
          partition by user_pseudo_id, event_params.ga_session_id
          order by time.event_timestamp asc
        ),
        null
     ) as hit_number,

    -- and page number
    if(user_pseudo_id is not null and event_params.ga_session_id is not null and batch.batch_page_id is not null,
        dense_rank() over (
          partition by user_pseudo_id, event_params.ga_session_id
          order by batch.batch_page_id asc
        ),
        null
     ) as page_number,

      if( MAX(event_params.session_engaged) OVER 
        (PARTITION BY event_date, session_id )  = 1, session_id, NULL) 
      as engaged_session_id 
      
    ) as session_info

  from deduped
)


select
  current_timestamp() as _run_timestamp, -- indicates when the row was last run
  *
from  add_row_numbers
where true



