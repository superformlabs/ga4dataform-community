/*
	This file is part of "GA4 Dataform Package".
	Copyright (C) 2023-2026 Superform Labs <support@superformlabs.eu>
	Artem Korneev, Jules Stuifbergen,
	Johan van de Werken, Kriszti√°n Korpa,
	Simon Breton

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License in the LICENSE.txt file for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

config {
  type: "incremental",
  tags: [dataform.projectConfig.vars.GA4_DATASET,"transactions","intermediate"],
  schema: dataform.projectConfig.vars.TRANSFORMATIONS_DATASET,
  description: "transactions table with nested items - so could be used as line_items table, too",
  bigquery: {
    partitionBy: "transaction_date",
    labels: require("includes/core/helpers.js").helpers.storageLabels()
  },
    columns: require("includes/core/documentation/helpers.js").ga4Transactions
}

js {
  const { helpers } = require("includes/core/modules/ga4/helpers");
  const config = helpers.getModuleConfig('ga4');
}

/* incrementality */
pre_operations {
  DECLARE date_checkpoint DATE;
  SET @@query_label = "${helpers.executionLabels()}";
  SET date_checkpoint = (
    ${when(incremental(),
      `SELECT
        COALESCE(MAX(transaction_date)+1, DATE('${config.GA4_START_DATE}'))
      FROM ${self()}
      WHERE is_final = TRUE`,
    `SELECT DATE('${config.GA4_START_DATE}')`)}   /* the default, when it's not incremental */
  );
  -- delete non-final data, since this may be updated later by GA4
  ${
    when(incremental(),
      `DELETE FROM ${self()} WHERE transaction_date >= date_checkpoint`
    )
  }
}

WITH source_purchase_and_refund_events AS (
  SELECT * FROM ${ref("ga4_events")}
  WHERE
    event_date >= date_checkpoint
    AND event_name IN ('purchase', 'refund') -- events is clustered by event_name, so it's pretty cheap
),

final_add_item_totals AS (
  -- we get the basic columns + ecommerce data, nested items + the item totals
  SELECT
    event_name,
    event_date AS transaction_date,
    is_final,
    ecommerce.transaction_id,
    event_id,
    session_id,
    user_pseudo_id,
    user_id,
    ${config.TRANSACTION_TOTALS_UID} AS uid,
    property_id,
    stream_id,
    platform,
    time,
    event_params.currency,
    event_params.coupon,
    STRUCT(
      ecommerce.total_item_quantity,
      ecommerce.purchase_revenue_in_usd,
      ecommerce.purchase_revenue,
      ecommerce.shipping_value_in_usd,
      ecommerce.shipping_value,
      ecommerce.tax_value_in_usd,
      ecommerce.tax_value,
      ecommerce.unique_items,
      ecommerce.refund_value_in_usd,
      ecommerce.refund_value
    ) AS ecommerce,
    items,
    STRUCT(
      (SELECT SUM(i.quantity) FROM UNNEST(items) AS i) AS quantity,
      (SELECT SUM(item_revenue) FROM UNNEST(items) AS i) AS item_revenue,
      (SELECT SUM(item_revenue_in_usd) FROM UNNEST(items) AS i) AS item_revenue_in_usd,
      (SELECT SUM(item_refund) FROM UNNEST(items) AS i) AS item_refund,
      (SELECT SUM(item_refund_in_usd) FROM UNNEST(items) AS i) AS item_refund_in_usd,
      (SELECT COUNTIF(i.coupon IS NOT NULL AND i.coupon != '(not set)') FROM UNNEST(items) AS i) AS coupons,
      (SELECT COALESCE(COUNT(DISTINCT IF(i.coupon = '(not set)', NULL, i.coupon)), 0) FROM UNNEST(items) AS i) AS unique_coupons
    ) AS item_totals

  FROM source_purchase_and_refund_events
)

SELECT *
FROM final_add_item_totals
